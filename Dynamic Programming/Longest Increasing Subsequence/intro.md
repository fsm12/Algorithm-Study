# 최장 증가 부분 수열 (LIS, Longest Increasing Subsequence)

</br>

## 개념

### 길이 N인 수열에서 앞에부터 뒤로 숫자를 증가하는 순서대로 선택해 나갈 때, 최대 길이를 갖는 수열

_"부분 수열은 연속적이거나, 유일할 필요는 없다"_

![LIS 수열 이미지](https://github.com/fsm12/Algorithm-Study/assets/74345771/e04ffda8-74e2-4f8d-a4fa-9fd996be04bb)

</br>
</br>

## 구현

### 1. O(N^2) : 모든 경우를 보자!

#### 진입 차수가 0인 노드부터 제거하고, 제거한 노드로부터의 간선을 삭제하는 과정을 반복하여 구현 가능

```java

```

</br>
</br>

### 2. O(NlogN) : 이분탐색을 통해 들어갈 자리를 찾자!

#### 최장 증가 부분 수열을 찾을 배열을 처음부터 확인하면서

```java
/*
A : 주어진 배열
lis : 최장 증가 부분 수열을 저장하는 배열
*/

// 처음 값은 넣고 시작
lis[0] = A[0];
curLen = 1;

// 주어진 배열을 순회하는데
for (int n=1; n<N; n++) {
    // 가장 마지막에 lis에 담긴 값보다 현재 배열의 값이 더 크다면
    if (lis[curLen-1] < A[n]) {
        // 뒤에 이어 붙여도되므로, 길이를 증가시켜주고 값을 붙인다.
        curLen++;
        lis[curLen-1] = A[n];
    } else { // 아니라면, lis엔 순서가 보장되어 있으므로 이분 탐색을 통해 적당한 위치를 찾아 값을 넣는다.
        int l=0, r=curLen;
        while (l<r) {
            int mid = (l+r)/2;
            if(lis[mid] < A[n])
                l = mid + 1;
            else
                r = mid;
        }
        lis[l] = A[n];
    }
}
```

</br>
</br>

## 해당 알고리즘을 사용해 푸는 문제

| 난이도 | 사이트 | 번호  | 문제이름                                                                                        | 이해도 |
| ------ | ------ | ----- | ----------------------------------------------------------------------------------------------- | ------ |
| 하     | 백준   | 12015 | <div align="center">[가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)</div> |        |
|        |        |       |                                                                                                 |        |
|        |        |       |                                                                                                 |        |
|        |        |       |                                                                                                 |        |
